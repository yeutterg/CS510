import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;


public class Movement {
	
	// Part 2.C: Move Generation
	
	public static Move possiblePieceMoves(int[][] state, int piece) {
		// return all possible moves for a piece given a game state
				
		// initialize possible moves matrix
		Set<Character> possibleMoves = new HashSet<Character>();
		
		// locate piece in game state
		ArrayList<int[]> pieceLocations = valueLocations(state, piece);
		
		// look for all zeros (empty) in game state
		ArrayList<int[]> zeroLocations = valueLocations(state, 0);
		possibleMoves.addAll(compareMoves(pieceLocations, zeroLocations));
		
		// if piece = master (2), look for -1 values as well
		if (piece == 2) {
			ArrayList<int[]> negOneLocations = valueLocations(state, -1);
			possibleMoves.addAll(compareMoves(pieceLocations, negOneLocations));
		}
		
		return new Move(piece, possibleMoves);
	}
	
	public static Move[] allPossiblePieceMoves(int[][] state) {
		// return all possible moves for all pieces given a game state
		
		// find all pieces in current game state (>= 2)
		ArrayList<Integer> currentPieces = new ArrayList<Integer>();
		for (int[] row : state) {
			for (int value : row) {
				if (!currentPieces.contains(value) && (value >= 2)) {
					currentPieces.add(value);
				}
			}
		}
		
		// run possiblePieceMoves for each value in currentPieces, and return
		Move[] allPossibleMoves = new Move[currentPieces.size()];
		int i = 0;
		for (int piece : currentPieces) {
			allPossibleMoves[i] = possiblePieceMoves(state, piece);
			i++;
		}
		
		return allPossibleMoves;
	}
	
	public static ArrayList<int[]> valueLocations(int[][] state, int value) {
		// Find and return coordinates of specific value in specified game state
		
		ArrayList<int[]> locations = new ArrayList<int[]>();
		int w = 0;
		int h = 0;
		for (int[] row : state) {
			for (int num : row) {
				if (num == value) {
					locations.add(new int[] {h, w});
				}
				w++;
			}
			h++;
			w = 0;
		}
		
		return locations;
	}
	
	public static ArrayList<Character> compareMoves(ArrayList<int[]> pieceState, 
			ArrayList<int[]> targetState) {
		// Compare two states and output possible moves
		
		ArrayList<Character> possibleMoves = new ArrayList<Character>();
		
		for (int[] cellPiece : pieceState) {
			int wPiece = cellPiece[1];
			int hPiece = cellPiece[0];
			for (int[] cellTarget : targetState) {
				int wTarget = cellTarget[1];
				int hTarget = cellTarget[0];
				
				if ((wTarget == (wPiece + 1)) && (hTarget == hPiece)) {
					// Possible to move right
					possibleMoves.add('r');
				} else if ((wTarget == (wPiece - 1)) && (hTarget == hPiece)) {
					// Possible to move left
					possibleMoves.add('l');
				} else if ((hTarget == (hPiece + 1)) && (wTarget == wPiece)) {
					// Possible to move up
					possibleMoves.add('u');
				} else if ((hTarget == (hPiece - 1)) && (wTarget == wPiece)) {
					// Possible to move down
					possibleMoves.add('d');
				}
			}
			
		}
		
		return possibleMoves;
	}
	
	public static ArrayList<Character> removeDuplicateMoves(ArrayList<Character> unfilteredMoves) {
		// Get rid of duplicate move values
		Set<Character> s = new TreeSet<Character>(new Comparator<Character>() {
			@Override
	        public int compare(Character c1, Character c2) {
				return 0;
			}
		});
		
		s.addAll(unFilteredMoves);
		return = Arrays.asArrayList(s.toArray());
			
	}
	
	

}
